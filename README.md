# Custom BPM

## Краткое описание

На данный момент здесь представлен минимальный функционал для построения и управления бизнес процессами. Возможно построить схему процесса в файле xml по особым правилам и загрузить ее сервис управления процессами. 

## Инструкция по запуску 

1) Склонируйте проект к себе на утсройство и перейдите в директорию с проектом 
2) Выполните команду ```./gradlew build```
3) Выполните команду ```docker network create bpm-net```
4) Выполните команду ```docker-compose up -d```

На данном этапе сервис запущен и готов к работе. Для тестовых нужд я добавил файл ```example_process.xml```. Это простой процесс, который получает при старте на вход параметр ```user_id(UUID)```, далее обращается к некоторому эндпоинту, передавя ему этот параметр и ожидает в ответ получить еще 2 параметра: ```condition(Boolean)``` и ```test_value(Numeric)```. На основе этих параметров происходит ветвление. 
Если ```condition == true``` и ```test_value == 0```, то процесс оканчивается с одним результатом. Если же хотя бы одно из условий не прошло проверку, то выполнение идет по иной ветки, в рамках которой делается запрос к другому эндпоинту с отправкой ```user_id(UUID)```, но результат уже не ожидается. После отправки запроса процесс сразу же заканчивается с иным результатом.
Перед запуском данного сценария следует открыть файл ```example_process.xml``` и заменить в нем ```endpoint_to_call``` на 2 разных эндпоинта, свойства которых описаны выше. Я для простоты тестирования использовал функцию ```Postman```, которая позволяет поднять сервис, который будет отвечать на определенные запросы определенным образом. 
После редактирования и сохранения файла, его можно загрузить в сервис через тот же ```Postman``` через эндпоинт ```localhost:8080/config/upload-scheme```, файл передается в теле запроса в качетсве параметра с именем ```file```.
Запустить процесс можно через эндпоинт ```localhost:8080/process/start``` с телом 
```json
{
    "schemeName": "example_process",
    "parameters": {
        "user_id": "some_random_uuid"
    }
}
```
Стадии процесса можно отслеживать через бд.
```yaml
url: jdbc:postgresql://localhost:5432/bpm
username: bpm
password: bpm
```

## Элементы схемы

#### Задача старт процесса 
Данная задача обязательна для построения схемы и содержится в ней в одном экземпляре.
Является точкой старта процесса и принимает на вход параметры, с которыми будет запущен процесс.

#### Задача вызов сервиса с ожидаемым результатом
Данная задача во время выполнения вызывает заданный эндпоинт по REST протоколу POST запросом,
передавая параметры, которые были для нее заданы (она берет их общих переменных процесса). 
В ответ на вызов задача ждет 200 статус. После этого процесс выполнения процесса встает 
на паузу и ожидает, когда в ответ на предыдущий вызов эндпоинта придет ответ (callback) с 
входящими параметрами, которые ожидаются задачей. Эти параметры будут сохранены в переменные процесса.

#### Задача вызов сервиса без ответа
Полностью аналогична предыдущему типу, однако не ожидает callback и сразу продолжает выполнение
после получения 200 статуса. 

#### Задача таймер
На данный момент не реализована корректным образом, поэтому ее не стоит использовать.

#### Задача ветвления и объединения процесса 
На данный момент имеется 2 вида подобных задач. Первый - singleton. При разбиении ветки на несколько новых 
этот процесс работает таким образом, что выполнение пойдет только по одной из них. По какой именно,
выбирается на основании условий, которые были наложены на связи с каждой из веток (типы связей будут описаны ниже).
Если же данный блок является соединением нескольких веток выполнения, то он начнет создавать исходящтие ветки 
только в том случае, когда все ветки входящие в него дойдут до него.
Второй тип - parallel. Когда ветка процесса доходит до выполнения этого блока, она разделяется 
на несколько параллельных веток (если условие на исходящей связи не выполняется, то по
данной ветке не будет создан подпроцесс). Если же данный блок соединяет несколько веток в себе, то 
каждая из них пройдет все последующие блоки.

#### Задача завершение процесса
Когда ветка выполнения доходит до этого блока, она корректно завершается. Если при этом 
она осталась последней активной веткой процесса, то процесс считается завершенным. 
Если хотя бы одна ветка процесса завершилась с ошибкой, то считается, что с ошибкой завершился 
весь процесс.

#### Связи блоков
Это связи, которые отвечают за переходы между блоками. Их существует 3 вида: 
```guaranteed```, ```default``` и ```conditional```. Первый тип самый простой, это ветка,
по которой процесс всегда может перейти в новое состояние. Второй тип используется только 
с singleton ветвлением. Для каждого singleton ветвления должна быть только 1 default ветка
(или 0, но рекомендуется создать 1). Если ни одно из условий на остальных ветках не будет 
выполнено, то выполнение пойдет по дефолтной. И последний тип подразумивает использование 
некоторых логических выражений над переменными процесса, на основе которых осуществляется переход.

## Логические выражения
Логические выражения на условных связях поддерживают синтаксис похожий на тот, который
используется в языках программирования с некоторыми оговорками.
Поддерживаются логические операции &&(и), ||(или), !(не). Поддерживаются скобочные последовательности.
Поддерживаются неравенства ==, !=, >, <, <=, >=, in, not in. Последние 2 работают только с массивами констант.
Логические выржаения поддерживают массивы, но на данный момент они могут состоять только из константных выражений.
логический выражения работают с перменными процесса, которые в свою очеред поддерживают 4 типа 
данных:
1) DATE - дата в формате (YYYY-MM-DD)
2) NUMERIC - числа ф ормате long
3) STRING - Обычные строки (берутся в одинарные кавычки)
4) BOOLEAN - Логический тип true или false, однако на данный момент нет возможности заменить выражения типа ```condition == true``` на простое ```condition```, обязательно доработаю это в будущем
Для обозначения переменной процесса в логическом выражении нужно просто записать ее имя. Если у процесса объявлена подобная переменная и процесс дошел до того момента, где ей задается значение, то она корректно подставится в выражение. В противном случае буедт ошибка.

## Правила разметки схемы

Заглавным тегом схемы является тег `<process></process>`, внутри него происходит конфигурация схемы.
Внутри данного блока есть несколько секций. Первая из них - `<parameterTypes></parameterTypes>`. Внутри 
нее задаются типы данных для перменных процесса. Например: `<parameterType name="user_id" type="string"/>`. 
Здесь для параметра с именем user_id был задан тип строки. Далее идет блок `<start></start>`. У него есть 
обязательынй атрибут `code`, который задает имя блока start. Внутри данного блока описываются параметры,
которые передаются при старте процесса. Напрмиер: `<startParameter innerName="user_id"/>`.
Далее идет блок с перечислением всех задач, которые есть внутри процесса - `<tasks></tasks>`. О его 
наполненни чуть ниже. Предпоследним блоком идет блок `<links></links>`, внутри него перечисляютяс 
все связи между остальными блоками. О них тоже чуть ниже. И последним блоком является блок 
задач окончания процесса - `<finishes></finishes>`. В нем перечисляются все задачи, отвечающие за 
окончание процесса. Например: `<finish code="default_result"/>`. У них, как и у большинства элементов схемы
есть обязательный атрибут code, который является уникальным идентификатором компонента в схеме.

#### Задачи 
Внутри перечисления задач каждая задача обозначается тегом `<task></task>`. У него необязательный
атрибут description, отвечающий за описание задачи, обязательный тег code, задающий 
уникальный идентификатор для задачи, обязательный атрибут type, описывающий тип задачи 
(call, call_with_result, timer, singleton_gate, parallel_gate). Внутри тега задачи
может быть несколько других тегов. Первый из них `<endpoint></endpoint>`. Он обязателен для задач 
типа call, в его теле записывается эндпоинт, который нужно вызывать. Далее идут 
2 тега, которые также относятся только к задачам типа call. Это `<input></input>` и `<output></output>`.
Внутри них перечисляются передаваемые и получаемые параметры соответственно. Напимер: `<parameter name="user_id" innerName="user_id"/>`.
Здесь в атрибуте innerName записано имя переменной процесса, а в атрибуте name записано имя параметра, который с котороым будет передано значение перменной.

#### Связи
Внутри блока перечилсения связей описываюстя все связи между блоками схемы. Они описываются в тегах `<link></link>`.
У каждого такого блока есть обязательный атрибут code, который является уникальным идентификатором свзяи в схеме.
Внутри есть 2 обязательных тега. Первый - `<from></from>`, в его теле записывается код блока,
из которого исходит связь. Второй - `<to></to>`. В его теле записывается код блока, в который ведет связь.
Третий тег необязательный - `<condition></condition>`. Если его нет, то связь считается `guaranteed`. 
Если же он присутствует, то у него есть обязательный атрибут - type. Он принимает 2 значения. Первое - default. 
С ним связь считается дефолтной. Второе - expression. В таком случае в теле тега записывается логическое выржание,
которые будет проверятся для перехода по данной связи. 

## Доступные эндпоинты

## Описание бд

## Что планируется улучшить в дальнейшем 
1) Доработать протокол общения с сервисами, вынести всю метаинформацию в хедеры, а пересылаемые параметры передавать в корректных форматах
2) Отдельным модулем разработать библиотеку для конечных сервисов, которая позволит не обрабтывать каждый запрос своими силами и корректно на него отвечать
3) Доработать механизм обработки ошибок, заменить все ```RunTimeException```'ы на соответствующие ошибки и избавиться от оставшихся в коде ```TODO```
4) В статусную модель ветки добавить ожидание завершения ```CallWithResult``` и ```Timer``` задач
5) Доделать задачи типа ```Timer```, на данный момент там стоит заглушка для минимального функционала, однако в конечном счете планируется вынести этот механизм в отдельную таблицу и сервис с шедулером, а также передавать время ожидание в удобочитаемом формате
6) Вынести большую часть настроек (таких как эндпоинты, к которым ображаются задачи типа ```Call```) в отдельный конфиг файл, который можно было бы использовать с разными профилями 
7) Добавить версионирование схем процессов
8) Добавить блокировки на ветки для параллельной обработки задач ветвления 
9) Сделать отдельный рекдактор схем 
10) Добавить разные сценарии обработки ошибок (полностью останавливать процесс или игнорировать ошибки в определенных ветках)
11) Добавить OpenAPI 
12) Доабвить поддержку сервера авторизации 
13) Сделать минимальный Web-интерфейс для просмотра состояния процессов
14) Написать тесты
15) Задокументировать код комментариями
16) Расширить функционал логических выражений